// Code generated by https://github.com/jamillosantos/go-ceous DO NOT EDIT

package db

import (
	"context"
	"database/sql"
	ceous "github.com/jamillosantos/go-ceous"
	tests "github.com/jamillosantos/go-ceous/tests"
)

type Creator interface {
	// UserQuery creates a new query related with the connection set.
	UserQuery(options ...ceous.CeousOption) *UserQuery
	// GroupQuery creates a new query related with the connection set.
	GroupQuery(options ...ceous.CeousOption) *GroupQuery
	// UserGroupQuery creates a new query related with the connection set.
	UserGroupQuery(options ...ceous.CeousOption) *UserGroupQuery
	// UserStore creates a new store related with the connection set.
	UserStore(options ...ceous.CeousOption) *UserStore
	// GroupStore creates a new store related with the connection set.
	GroupStore(options ...ceous.CeousOption) *GroupStore
	// UserGroupStore creates a new store related with the connection set.
	UserGroupStore(options ...ceous.CeousOption) *UserGroupStore
}

type Connection interface {
	ceous.DBRunner
	Creator
}
type defaultConnection struct {
	*ceous.BaseConnection
}

// UserQuery creates a new query related with the connection default set.
func (c *defaultConnection) UserQuery(options ...ceous.CeousOption) *UserQuery {
	return NewUserQuery(append(options, ceous.WithConn(c))...)
}

// GroupQuery creates a new query related with the connection default set.
func (c *defaultConnection) GroupQuery(options ...ceous.CeousOption) *GroupQuery {
	return NewGroupQuery(append(options, ceous.WithConn(c))...)
}

// UserGroupQuery creates a new query related with the connection default set.
func (c *defaultConnection) UserGroupQuery(options ...ceous.CeousOption) *UserGroupQuery {
	return NewUserGroupQuery(append(options, ceous.WithConn(c))...)
}

// UserStore creates a new store related with the connection default set.
func (c *defaultConnection) UserStore(options ...ceous.CeousOption) *UserStore {
	return NewUserStore(append(options, ceous.WithConn(c))...)
}

// GroupStore creates a new store related with the connection default set.
func (c *defaultConnection) GroupStore(options ...ceous.CeousOption) *GroupStore {
	return NewGroupStore(append(options, ceous.WithConn(c))...)
}

// UserGroupStore creates a new store related with the connection default set.
func (c *defaultConnection) UserGroupStore(options ...ceous.CeousOption) *UserGroupStore {
	return NewUserGroupStore(append(options, ceous.WithConn(c))...)
}

// Begin creates a new transaction with default set.
func (c *defaultConnection) Begin() (*Transaction, error) {
	tx, err := c.BaseConnection.Begin()
	if err != nil {
		return nil, err
	}
	return NewTransaction(tx), nil
}

// BeginTx creates a new transaction with extended config params with the
// connection default set.
func (c *defaultConnection) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Transaction, error) {
	tx, err := c.BaseConnection.BeginTx(ctx, opts)
	if err != nil {
		return nil, err
	}
	return NewTransaction(tx), nil
}

var (
	// Default is a database connection reference.
	Default *defaultConnection
)

// InitDefault initializes the connection `Default:`.
func InitDefault(db *sql.DB) {
	Default = &defaultConnection{
		BaseConnection: ceous.NewConnection(db),
	}
}

type Transaction struct {
	*ceous.BaseTxRunner
}

func NewTransaction(tx *ceous.BaseTxRunner) *Transaction {
	return &Transaction{
		BaseTxRunner: tx,
	}
}

// UserQuery creates a new query from a transaction.
func (c *Transaction) UserQueryQuery(options ...ceous.CeousOption) *UserQuery {
	return NewUserQuery(append(options, ceous.WithRunner(c))...)
}

// GroupQuery creates a new query from a transaction.
func (c *Transaction) GroupQueryQuery(options ...ceous.CeousOption) *GroupQuery {
	return NewGroupQuery(append(options, ceous.WithRunner(c))...)
}

// UserGroupQuery creates a new query from a transaction.
func (c *Transaction) UserGroupQueryQuery(options ...ceous.CeousOption) *UserGroupQuery {
	return NewUserGroupQuery(append(options, ceous.WithRunner(c))...)
}

// UserStore creates a new store from a transaction.
func (c *Transaction) UserStoreStore(options ...ceous.CeousOption) *UserStore {
	return NewUserStore(append(options, ceous.WithRunner(c))...)
}

// GroupStore creates a new store from a transaction.
func (c *Transaction) GroupStoreStore(options ...ceous.CeousOption) *GroupStore {
	return NewGroupStore(append(options, ceous.WithRunner(c))...)
}

// UserGroupStore creates a new store from a transaction.
func (c *Transaction) UserGroupStoreStore(options ...ceous.CeousOption) *UserGroupStore {
	return NewUserGroupStore(append(options, ceous.WithRunner(c))...)
}

type schema struct {
	User      *schemaUser
	Group     *schemaGroup
	UserGroup *schemaUserGroup
}

// schemaUserAddress have all fields for the model UserAddress.
type schemaUserAddress struct {
	Street ceous.SchemaField
	Number ceous.SchemaField
	City   ceous.SchemaField
	State  ceous.SchemaField
}

// schemaUserWork have all fields for the model UserWork.
type schemaUserWork struct {
	Street ceous.SchemaField
	Number ceous.SchemaField
	City   ceous.SchemaField
	State  ceous.SchemaField
}

// schemaUser have all fields for the model User.
type schemaUser struct {
	*ceous.BaseSchema

	ID        ceous.SchemaField
	Name      ceous.SchemaField
	Password  ceous.SchemaField
	Role      ceous.SchemaField
	Address   schemaUserAddress
	Work      schemaUserWork
	CreatedAt ceous.SchemaField
	UpdatedAt ceous.SchemaField
}

// schemaGroup have all fields for the model Group.
type schemaGroup struct {
	*ceous.BaseSchema

	ID   ceous.SchemaField
	Name ceous.SchemaField
}

// schemaUserGroupID have all fields for the model UserGroupID.
type schemaUserGroupID struct {
	UserID  ceous.SchemaField
	GroupID ceous.SchemaField
}

// schemaUserGroup have all fields for the model UserGroup.
type schemaUserGroup struct {
	*ceous.BaseSchema

	ID    schemaUserGroupID
	Admin ceous.SchemaField
}

// UserQuery is the query for the model `UserQuery`.
type UserQuery struct {
	*ceous.BaseQuery
	ID        ceous.SchemaField
	Name      ceous.SchemaField
	Password  ceous.SchemaField
	Role      ceous.SchemaField
	Address   ceous.SchemaField
	Work      ceous.SchemaField
	CreatedAt ceous.SchemaField
	UpdatedAt ceous.SchemaField
}

// NewUserQuery creates a new query for model `UserQuery`.
func NewUserQuery(options ...ceous.CeousOption) *UserQuery {
	bq := ceous.NewBaseQuery(options...)
	if bq.Schema == nil {
		bq.Schema = tests.Schema.User.BaseSchema
	}
	return &UserQuery{
		BaseQuery: bq,
	}
}

// ByID add a filter by `ID`.
func (q *UserQuery) ByID(value int) *UserQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.ID, value))
	return q
}

// ByName add a filter by `Name`.
func (q *UserQuery) ByName(value string) *UserQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.Name, value))
	return q
}

// ByPassword add a filter by `Password`.
func (q *UserQuery) ByPassword(value string) *UserQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.Password, value))
	return q
}

// ByRole add a filter by `Role`.
func (q *UserQuery) ByRole(value string) *UserQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.Role, value))
	return q
}

// ByAddress add a filter by `Address`.
func (q *UserQuery) ByAddress(value Address) *UserQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.Address, value))
	return q
}

// ByWork add a filter by `Work`.
func (q *UserQuery) ByWork(value Address) *UserQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.Work, value))
	return q
}

// ByCreatedAt add a filter by `CreatedAt`.
func (q *UserQuery) ByCreatedAt(value time.Time) *UserQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.CreatedAt, value))
	return q
}

// ByUpdatedAt add a filter by `UpdatedAt`.
func (q *UserQuery) ByUpdatedAt(value time.Time) *UserQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.UpdatedAt, value))
	return q
}

// Select defines what fields should be selected from the database.
func (q *UserQuery) Select(fields ...ceous.SchemaField) *UserQuery {
	q.BaseQuery.Select(fields...)
	return q
}

// ExcludeFields defines what fields should not be selected from the database.
func (q *UserQuery) ExcludeFields(fields ...ceous.SchemaField) *UserQuery {
	q.BaseQuery.ExcludeFields(fields...)
	return q
}

// Where defines the conditions for
func (q *UserQuery) Where(pred interface{}, args ...interface{}) *UserQuery {
	q.BaseQuery.Where(pred, args...)
	return q
}

func (q *UserQuery) Limit(limit uint64) *UserQuery {
	q.BaseQuery.Limit(limit)
	return q
}

func (q *UserQuery) Offset(offset uint64) *UserQuery {
	q.BaseQuery.Offset(offset)
	return q
}

// One results only one record matching the query.
func (q *UserQuery) One() (m tests.UserQuery, err error) {
	q.Limit(1).Offset(0)

	query, err := q.RawQuery()
	if err != nil {
		return
	}

	rs := NewUserQueryResultSet(query, nil)
	defer rs.Close()

	if rs.Next() {
		err = rs.ToModel(&m)
		if err != nil {
			return
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(&m)
			if err != nil {
				return tests.UserQuery{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	} else {
		err = ceous.ErrNotFound
	}

	if err == nil {
		for _, rel := range q.BaseQuery.Relations {
			err = rel.Realize()
			if err != nil {
				return tests.UserQuery{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	}

	return
}

// All return all records that match the query.
func (q *UserQuery) All() ([]*tests.UserQuery, error) {
	query, err := q.RawQuery()
	if err != nil {
		return nil, err
	}

	rs := NewUserQueryResultSet(query, nil)
	defer rs.Close()

	ms := make([]*tests.UserQuery, 0)
	for rs.Next() {
		m := &tests.UserQuery{}
		err = rs.ToModel(m)
		if err != nil {
			return nil, err
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(m)
			if err != nil {
				return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
		ms = append(ms, m)
	}

	for _, rel := range q.BaseQuery.Relations {
		err = rel.Realize()
		if err != nil {
			return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
		}
	}

	return ms, nil
}

func (q *UserQuery) OrderBy(fields ...interface{}) *UserQuery {
	q.BaseQuery.OrderBy(fields...)
	return q
}

// GroupQuery is the query for the model `GroupQuery`.
type GroupQuery struct {
	*ceous.BaseQuery
	ID   ceous.SchemaField
	Name ceous.SchemaField
}

// NewGroupQuery creates a new query for model `GroupQuery`.
func NewGroupQuery(options ...ceous.CeousOption) *GroupQuery {
	bq := ceous.NewBaseQuery(options...)
	if bq.Schema == nil {
		bq.Schema = tests.Schema.Group.BaseSchema
	}
	return &GroupQuery{
		BaseQuery: bq,
	}
}

// ByID add a filter by `ID`.
func (q *GroupQuery) ByID(value int) *GroupQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.ID, value))
	return q
}

// ByName add a filter by `Name`.
func (q *GroupQuery) ByName(value string) *GroupQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.Name, value))
	return q
}

// Select defines what fields should be selected from the database.
func (q *GroupQuery) Select(fields ...ceous.SchemaField) *GroupQuery {
	q.BaseQuery.Select(fields...)
	return q
}

// ExcludeFields defines what fields should not be selected from the database.
func (q *GroupQuery) ExcludeFields(fields ...ceous.SchemaField) *GroupQuery {
	q.BaseQuery.ExcludeFields(fields...)
	return q
}

// Where defines the conditions for
func (q *GroupQuery) Where(pred interface{}, args ...interface{}) *GroupQuery {
	q.BaseQuery.Where(pred, args...)
	return q
}

func (q *GroupQuery) Limit(limit uint64) *GroupQuery {
	q.BaseQuery.Limit(limit)
	return q
}

func (q *GroupQuery) Offset(offset uint64) *GroupQuery {
	q.BaseQuery.Offset(offset)
	return q
}

// One results only one record matching the query.
func (q *GroupQuery) One() (m tests.GroupQuery, err error) {
	q.Limit(1).Offset(0)

	query, err := q.RawQuery()
	if err != nil {
		return
	}

	rs := NewGroupQueryResultSet(query, nil)
	defer rs.Close()

	if rs.Next() {
		err = rs.ToModel(&m)
		if err != nil {
			return
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(&m)
			if err != nil {
				return tests.GroupQuery{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	} else {
		err = ceous.ErrNotFound
	}

	if err == nil {
		for _, rel := range q.BaseQuery.Relations {
			err = rel.Realize()
			if err != nil {
				return tests.GroupQuery{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	}

	return
}

// All return all records that match the query.
func (q *GroupQuery) All() ([]*tests.GroupQuery, error) {
	query, err := q.RawQuery()
	if err != nil {
		return nil, err
	}

	rs := NewGroupQueryResultSet(query, nil)
	defer rs.Close()

	ms := make([]*tests.GroupQuery, 0)
	for rs.Next() {
		m := &tests.GroupQuery{}
		err = rs.ToModel(m)
		if err != nil {
			return nil, err
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(m)
			if err != nil {
				return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
		ms = append(ms, m)
	}

	for _, rel := range q.BaseQuery.Relations {
		err = rel.Realize()
		if err != nil {
			return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
		}
	}

	return ms, nil
}

func (q *GroupQuery) OrderBy(fields ...interface{}) *GroupQuery {
	q.BaseQuery.OrderBy(fields...)
	return q
}

// UserGroupQuery is the query for the model `UserGroupQuery`.
type UserGroupQuery struct {
	*ceous.BaseQuery
	ID    ceous.SchemaField
	user  ceous.SchemaField
	Admin ceous.SchemaField
}

// NewUserGroupQuery creates a new query for model `UserGroupQuery`.
func NewUserGroupQuery(options ...ceous.CeousOption) *UserGroupQuery {
	bq := ceous.NewBaseQuery(options...)
	if bq.Schema == nil {
		bq.Schema = tests.Schema.UserGroup.BaseSchema
	}
	return &UserGroupQuery{
		BaseQuery: bq,
	}
}

// ByID add a filter by `ID`.
func (q *UserGroupQuery) ByID(value UserGroupPK) *UserGroupQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.ID, value))
	return q
}

// Byuser add a filter by `user`.
func (q *UserGroupQuery) Byuser(value User) *UserGroupQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.user, value))
	return q
}

// ByAdmin add a filter by `Admin`.
func (q *UserGroupQuery) ByAdmin(value bool) *UserGroupQuery {
	q.BaseQuery.Where(ceous.Eq(tests.Schema.Admin, value))
	return q
}

// Select defines what fields should be selected from the database.
func (q *UserGroupQuery) Select(fields ...ceous.SchemaField) *UserGroupQuery {
	q.BaseQuery.Select(fields...)
	return q
}

// ExcludeFields defines what fields should not be selected from the database.
func (q *UserGroupQuery) ExcludeFields(fields ...ceous.SchemaField) *UserGroupQuery {
	q.BaseQuery.ExcludeFields(fields...)
	return q
}

// Where defines the conditions for
func (q *UserGroupQuery) Where(pred interface{}, args ...interface{}) *UserGroupQuery {
	q.BaseQuery.Where(pred, args...)
	return q
}

func (q *UserGroupQuery) Limit(limit uint64) *UserGroupQuery {
	q.BaseQuery.Limit(limit)
	return q
}

func (q *UserGroupQuery) Offset(offset uint64) *UserGroupQuery {
	q.BaseQuery.Offset(offset)
	return q
}

// One results only one record matching the query.
func (q *UserGroupQuery) One() (m tests.UserGroupQuery, err error) {
	q.Limit(1).Offset(0)

	query, err := q.RawQuery()
	if err != nil {
		return
	}

	rs := NewUserGroupQueryResultSet(query, nil)
	defer rs.Close()

	if rs.Next() {
		err = rs.ToModel(&m)
		if err != nil {
			return
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(&m)
			if err != nil {
				return tests.UserGroupQuery{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	} else {
		err = ceous.ErrNotFound
	}

	if err == nil {
		for _, rel := range q.BaseQuery.Relations {
			err = rel.Realize()
			if err != nil {
				return tests.UserGroupQuery{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	}

	return
}

// All return all records that match the query.
func (q *UserGroupQuery) All() ([]*tests.UserGroupQuery, error) {
	query, err := q.RawQuery()
	if err != nil {
		return nil, err
	}

	rs := NewUserGroupQueryResultSet(query, nil)
	defer rs.Close()

	ms := make([]*tests.UserGroupQuery, 0)
	for rs.Next() {
		m := &tests.UserGroupQuery{}
		err = rs.ToModel(m)
		if err != nil {
			return nil, err
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(m)
			if err != nil {
				return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
		ms = append(ms, m)
	}

	for _, rel := range q.BaseQuery.Relations {
		err = rel.Realize()
		if err != nil {
			return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
		}
	}

	return ms, nil
}

func (q *UserGroupQuery) OrderBy(fields ...interface{}) *UserGroupQuery {
	q.BaseQuery.OrderBy(fields...)
	return q
}

// User is the query for the store `User`.
type User struct {
	*ceous.BaseStore
}

// NewUser creates a new query for model `User`.
func NewUserStore(options ...ceous.CeousOption) *User {
	return &User{
		BaseStore: ceous.NewStore(tests.Schema.User, options...),
	}
}

func (store *User) Insert(record *tests.User, fields ...ceous.SchemaField) error {
	return store.BaseStore.Insert(record, fields...)
}

func (store *User) Update(record *tests.User, fields ...ceous.SchemaField) (int64, error) {
	return store.BaseStore.Update(record, fields...)
}

// Group is the query for the store `Group`.
type Group struct {
	*ceous.BaseStore
}

// NewGroup creates a new query for model `Group`.
func NewGroupStore(options ...ceous.CeousOption) *Group {
	return &Group{
		BaseStore: ceous.NewStore(tests.Schema.Group, options...),
	}
}

func (store *Group) Insert(record *tests.Group, fields ...ceous.SchemaField) error {
	return store.BaseStore.Insert(record, fields...)
}

func (store *Group) Update(record *tests.Group, fields ...ceous.SchemaField) (int64, error) {
	return store.BaseStore.Update(record, fields...)
}

// UserGroup is the query for the store `UserGroup`.
type UserGroup struct {
	*ceous.BaseStore
}

// NewUserGroup creates a new query for model `UserGroup`.
func NewUserGroupStore(options ...ceous.CeousOption) *UserGroup {
	return &UserGroup{
		BaseStore: ceous.NewStore(tests.Schema.UserGroup, options...),
	}
}

func (store *UserGroup) Insert(record *tests.UserGroup, fields ...ceous.SchemaField) error {
	return store.BaseStore.Insert(record, fields...)
}

func (store *UserGroup) Update(record *tests.UserGroup, fields ...ceous.SchemaField) (int64, error) {
	return store.BaseStore.Update(record, fields...)
}
