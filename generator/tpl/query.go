// This file is generated by gorazor 2.0.1
// DON'T modified manually
// Should edit source file and re-generate: tpl/query.gohtml

package tpl

import (
	. "github.com/jamillosantos/go-ceous/generator/helpers"
	"github.com/jamillosantos/go-ceous/generator/models"
	"github.com/sipin/gorazor/gorazor"
	"io"
	"strings"
)

// Query generates tpl/query.gohtml
func Query(env *models.Environment, query *models.Query) string {
	var _b strings.Builder
	RenderQuery(&_b, env, query)
	return _b.String()
}

// RenderQuery render tpl/query.gohtml
func RenderQuery(_buffer io.StringWriter, env *models.Environment, query *models.Query) {
	_buffer.WriteString("\n\n// ")
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" is the query for the model `")
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString("`.\ntype ")
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" struct {\n\t*ceous.BaseQuery\n}\n\n// New")
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" creates a new query for model `")
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString("`.\nfunc New")
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString("(options ...ceous.CeousOption) ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" {\n\tbq := ceous.NewBaseQuery(options...)\n\tif bq.Schema == nil {\n\t\tbq.Schema = ")
	_buffer.WriteString(gorazor.HTMLEscape(env.InputPkgCtx.Ref(env.OutputPkg, "Schema")))
	_buffer.WriteString(".")
	_buffer.WriteString(gorazor.HTMLEscape(query.Name))
	_buffer.WriteString(".BaseSchema\n\t}\n\treturn ")
	_buffer.WriteString(("&"))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString("{\n\t\tBaseQuery: bq,\n\t}\n}\n\n// For add a FOR [UPDATE|NO KEY UPDATE|SHARE|KEY SHARE] [NOWAIT|SKIP LOCKED] directive for the key.\nfunc (q ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(") For(t ceous.SelectForType, lockingType ...ceous.SelectForLockingType) ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" {\n\tq.BaseQuery.For(t, lockingType...)\n\treturn q\n}")
	for _, field := range query.Fields {
		_buffer.WriteString("\n// By")
		_buffer.WriteString(gorazor.HTMLEscape(field.Name))
		_buffer.WriteString(" add a filter by `")
		_buffer.WriteString(gorazor.HTMLEscape(field.Name))
		_buffer.WriteString("`.\nfunc (q ")
		_buffer.WriteString(gorazor.HTMLEscape(Pointer))
		_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
		_buffer.WriteString(") By")
		_buffer.WriteString(gorazor.HTMLEscape(field.MethodName))
		_buffer.WriteString("(value ")
		_buffer.WriteString(gorazor.HTMLEscape(field.Type))
		_buffer.WriteString(") ")
		_buffer.WriteString(gorazor.HTMLEscape(Pointer))
		_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
		_buffer.WriteString(" {\n\tq.BaseQuery.Where(ceous.Eq(")
		_buffer.WriteString(gorazor.HTMLEscape(env.InputPkgCtx.Ref(env.OutputPkg, "Schema")))
		_buffer.WriteString(".")
		_buffer.WriteString(gorazor.HTMLEscape(query.Name))
		_buffer.WriteString(".")
		_buffer.WriteString(gorazor.HTMLEscape(field.FieldPath))
		_buffer.WriteString(", value))\n\treturn q\n}")
	}
	_buffer.WriteString("\n\n// Select defines what fields should be selected from the database.\nfunc (q ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(") Select(fields ...ceous.SchemaField) ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" {\n\tq.BaseQuery.Select(fields...)\n\treturn q\n}\n\n// ExcludeFields defines what fields should not be selected from the database.\nfunc (q ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(") ExcludeFields(fields ...ceous.SchemaField) ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" {\n\tq.BaseQuery.ExcludeFields(fields...)\n\treturn q\n}\n\n// Where defines the conditions for \nfunc (q ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(") Where(pred interface{}, args ...interface{}) ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" {\n\tq.BaseQuery.Where(pred, args...)\n\treturn q\n}\n\nfunc (q ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(") Limit(limit uint64) ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" {\n\tq.BaseQuery.Limit(limit)\n\treturn q\n}\n\nfunc (q ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(") Offset(offset uint64) ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" {\n\tq.BaseQuery.Offset(offset)\n\treturn q\n}\n\n// One results only one record matching the query.\nfunc (q ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(") One() (m ")
	_buffer.WriteString(gorazor.HTMLEscape(env.InputPkgCtx.Ref(env.OutputPkg, query.Name)))
	_buffer.WriteString(", err error) {\n\tq.Limit(1).Offset(0)\n\n\tquery, err := q.RawQuery()\n\tif err != nil {\n\t\treturn\n\t}\n\n\trs := New")
	_buffer.WriteString(gorazor.HTMLEscape(query.Name))
	_buffer.WriteString("ResultSet(query, nil)\n\tdefer rs.Close()\n\n\tif rs.Next() {\n\t\terr = rs.ToModel(&m)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tceous.MakeWritable(&m)\n\n\t\tfor _, rel := range q.BaseQuery.Relations {\n\t\t\terr = rel.Aggregate(&m)\n\t\t\tif err != nil {\n\t\t\t\treturn ")
	_buffer.WriteString(gorazor.HTMLEscape(env.InputPkgCtx.Ref(env.OutputPkg, query.Name)))
	_buffer.WriteString("{}, err // TODO(jota): Shall this error be wrapped? At first, yes.\n\t\t\t}\n\t\t}\n\t} else {\n\t\terr = ceous.ErrNotFound\n\t}\n\n\tif err == nil {\n\t\tfor _, rel := range q.BaseQuery.Relations {\n\t\t\terr = rel.Realize()\n\t\t\tif err != nil {\n\t\t\t\treturn ")
	_buffer.WriteString(gorazor.HTMLEscape(env.InputPkgCtx.Ref(env.OutputPkg, query.Name)))
	_buffer.WriteString("{}, err // TODO(jota): Shall this error be wrapped? At first, yes.\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n\n// All return all records that match the query.\nfunc (q ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(") All() ([]")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(env.InputPkgCtx.Ref(env.OutputPkg, query.Name)))
	_buffer.WriteString(", error) {\n\tquery, err := q.RawQuery()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trs := New")
	_buffer.WriteString(gorazor.HTMLEscape(query.Name))
	_buffer.WriteString("ResultSet(query, nil)\n\tdefer rs.Close()\n\n\tms := make([]")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(env.InputPkgCtx.Ref(env.OutputPkg, query.Name)))
	_buffer.WriteString(", 0)\n\tfor rs.Next() {\n\t\tm := &")
	_buffer.WriteString(gorazor.HTMLEscape(env.InputPkgCtx.Ref(env.OutputPkg, query.Name)))
	_buffer.WriteString("{}\n\t\terr = rs.ToModel(m)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tceous.MakeWritable(m)\n\n\t\tfor _, rel := range q.BaseQuery.Relations {\n\t\t\terr = rel.Aggregate(m)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err // TODO(jota): Shall this error be wrapped? At first, yes.\n\t\t\t}\n\t\t}\n\t\tms = append(ms, m)\n\t}\n\n\tfor _, rel := range q.BaseQuery.Relations {\n\t\terr = rel.Realize()\n\t\tif err != nil {\n\t\t\treturn nil, err // TODO(jota): Shall this error be wrapped? At first, yes.\n\t\t}\n\t}\n\n\treturn ms, nil\n}\n\nfunc (q ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(") OrderBy(fields ...interface{}) ")
	_buffer.WriteString(gorazor.HTMLEscape(Pointer))
	_buffer.WriteString(gorazor.HTMLEscape(query.FullName))
	_buffer.WriteString(" {\n\tq.BaseQuery.OrderBy(fields...)\n\treturn q\n}")
	for _, relation := range query.Relations {
		RenderRelation(_buffer, env, relation)
	}

}
