@{
	import "github.com/jamillosantos/go-ceous/generator/models"
	import . "github.com/jamillosantos/go-ceous/generator/helpers"

	var env *models.Environment
	var relation *models.Relation
}

type @relation.Name@: struct {
	_runner ceous.DBRunner
	keys []interface{}
	records map[@relation.LocalModelType][]@Pointer@relation.ForeignModelType
}

func New@relation.Name@:(runner ceous.DBRunner) @Pointer@relation.Name@: {
	return @raw("&")@relation.Name@:{
		_runner: runner,
		keys:    make([]interface{}, 0),
		records: make(map[@relation.LocalModelType][]@Pointer@relation.ForeignModelType@:),
	}
}

func (relation @Pointer@relation.Name@:) Aggregate(record ceous.Record) error {
	ugRecord, ok := record.(@Pointer@relation.LocalModelType)
	if !ok {
		return ceous.ErrInvalidRecordType
	}
	if rs, ok := relation.records[ugRecord.@relation.LocalColumn@:]; ok {
		relation.records[ugRecord.@relation.LocalColumn@:] = append(rs, ugRecord)
		// No need to add the key here, since its will be already in the `keys`.
	} else {
		relation.records[ugRecord.@relation.LocalColumn@:] = append(rs, ugRecord)
		relation.keys = append(relation.keys, ugRecord.@relation.LocalColumn@:)
	}
	return nil
}

func (relation @Pointer@relation.Name@:) Realize() error {
	records, err := NewUserQuery(ceous.WithRunner(relation._runner)).Where(ceous.Eq(@env.InputPkgCtx.Ref(env.OutputPkg, "Schema").@relation.ForeignModelType@:.ID, relation.keys)).All()
	if err != nil {
		return err // TODO(jota): Shall this be wrapped into a custom error?
	}
	for _, record := range records {
		masterRecords, ok := relation.records[record.ID]
		if !ok {
			return ceous.ErrInconsistentRelationResult
		}
		for _, r := range masterRecords {
			r.Set@PascalCase(relation.LocalColumn)@:(record)
		}
	}
	return nil
}

func (q @Pointer@relation.Query.Name@:) With@PascalCase(relation.Name)@:() @Pointer@relation.Query.Name@: {
	q.BaseQuery.Relations = append(q.BaseQuery.Relations, New@relation.Name@:(q.BaseQuery.Runner))
	return q
}
