@{
	import "github.com/jamillosantos/go-ceous/generator/models"
	import . "github.com/jamillosantos/go-ceous/generator/helpers"
	
	var env *models.Environment
	var query *models.Query
}

// @query.Name is the query for the model `@query.Name`.
type @query.Name@: struct {
	*ceous.BaseQuery
@for _, field := range query.Fields {@
	@field.Name	ceous.SchemaField
}
}

// New@query.Name@:Query creates a new query for model `@query.Name`.
func New@query.Name@:Query(options ...ceous.CeousOption) @Pointer@query.Name@: {
	bq := ceous.NewBaseQuery(options...)
	if bq.Schema == nil {
		bq.Schema = @env.InputPkgCtx.Ref(env.OutputPkg, "Schema")@:.@query.Name@:.BaseSchema
	}
	return @raw("&")@query.Name@:{
		BaseQuery: bq,
	}
}

@for _, field := range query.Fields {@
// By@field.Name add a filter by `@field.Name@:`.
func (q @Pointer@query.Name) By@field.Name@:(value @field.Type@:) @Pointer@query.Name@: {
	q.BaseQuery.Where(ceous.Eq(@env.InputPkgCtx.Ref(env.OutputPkg, "Schema")@:.@field.Name@:, value@:))
	return q
}

}

// Select defines what fields should be selected from the database.
func (q @Pointer@query.Name) Select(fields ...ceous.SchemaField) @Pointer@query.Name {
	q.BaseQuery.Select(fields...)
	return q
}

// ExcludeFields defines what fields should not be selected from the database.
func (q @Pointer@query.Name) ExcludeFields(fields ...ceous.SchemaField) @Pointer@query.Name {
	q.BaseQuery.ExcludeFields(fields...)
	return q
}

// Where defines the conditions for 
func (q @Pointer@query.Name) Where(pred interface{}, args ...interface{}) @Pointer@query.Name {
	q.BaseQuery.Where(pred, args...)
	return q
}

func (q @Pointer@query.Name) Limit(limit uint64) @Pointer@query.Name {
	q.BaseQuery.Limit(limit)
	return q
}

func (q @Pointer@query.Name) Offset(offset uint64) @Pointer@query.Name {
	q.BaseQuery.Offset(offset)
	return q
}

// One results only one record matching the query.
func (q @Pointer@query.Name) One() (m @env.InputPkgCtx.Ref(env.OutputPkg, query.Name)@:, err error) {
	q.Limit(1).Offset(0)

	query, err := q.RawQuery()
	if err != nil {
		return
	}

	rs := New@query.Name@:ResultSet(query, nil)
	defer rs.Close()

	if rs.Next() {
		err = rs.ToModel(&m)
		if err != nil {
			return
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(&m)
			if err != nil {
				return @env.InputPkgCtx.Ref(env.OutputPkg, query.Name)@:{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	} else {
		err = ceous.ErrNotFound
	}

	if err == nil {
		for _, rel := range q.BaseQuery.Relations {
			err = rel.Realize()
			if err != nil {
				return @env.InputPkgCtx.Ref(env.OutputPkg, query.Name)@:{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	}

	return
}

// All return all records that match the query.
func (q @Pointer@query.Name) All() ([]@Pointer@env.InputPkgCtx.Ref(env.OutputPkg, query.Name)@:, error) {
	query, err := q.RawQuery()
	if err != nil {
		return nil, err
	}

	rs := New@query.Name@:ResultSet(query, nil)
	defer rs.Close()

	ms := make([]@Pointer@env.InputPkgCtx.Ref(env.OutputPkg, query.Name)@:, 0)
	for rs.Next() {
		m := &@env.InputPkgCtx.Ref(env.OutputPkg, query.Name)@:{}
		err = rs.ToModel(m)
		if err != nil {
			return nil, err
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(m)
			if err != nil {
				return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
		ms = append(ms, m)
	}

	for _, rel := range q.BaseQuery.Relations {
		err = rel.Realize()
		if err != nil {
			return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
		}
	}

	return ms, nil
}

func (q @Pointer@query.Name) OrderBy(fields ...interface{}) @Pointer@query.Name {
	q.BaseQuery.OrderBy(fields...)
	return q
}


@for _, relation := range query.Relations {
	RenderRelation(_buffer, ctx, relation)
}
