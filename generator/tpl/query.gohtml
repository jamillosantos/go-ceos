@{
	import "github.com/jamillosantos/go-ceous/generator/models"

	import myasthurts "github.com/lab259/go-my-ast-hurts"

	var pkg *myasthurts.Package
	var model *models.Model
}

// @model.QueryName() is the query for the model `@model.Name`.
type @model.QueryName()@: struct {
	*ceous.BaseQuery
@for _, field := range model.Fields {
	@raw("\n")
@	@field.Name	ceous.SchemaField
}
}

// New@model.Name@:Query creates a new query for model `@model.Name`.
func New@model.Name@:Query(options ...ceous.CeousOption) @raw("*")@model.QueryName()@: {
	bq := ceous.NewBaseQuery(options...)
	if bq.Schema == nil {
		bq.Schema = Schema.@model.Name@:.BaseSchema
	}
@	return &@model.QueryName()@:{
		BaseQuery: bq,
	}
}

@for _, field := range model.Conditions {
	@raw("\n\n")
	@// By@field.NameForMethod@: add a filter by `@field.Field@:`.
@:func (q @raw("*")@model.QueryName()) By@field.NameForMethod@:(value @field.Type@:) @raw("*")@model.QueryName()@: {
	@for _, condition := range field.Conditions {
@	q.BaseQuery.Where(ceous.Eq(Schema.@condition.SchemaField@:, value@condition.StringField()@:))
	}
	return q
}
}

// Select defines what fields should be selected from the database.
func (q @raw("*")@model.QueryName()) Select(fields ...ceous.SchemaField) @raw("*")@model.QueryName() {
	q.BaseQuery.Select(fields...)
	return q
}

// ExcludeFields defines what fields should not be selected from the database.
func (q @raw("*")@model.QueryName()) ExcludeFields(fields ...ceous.SchemaField) @raw("*")@model.QueryName() {
	q.BaseQuery.ExcludeFields(fields...)
	return q
}

// Where defines the conditions for 
func (q @raw("*")@model.QueryName()) Where(pred interface{}, args ...interface{}) @raw("*")@model.QueryName() {
	q.BaseQuery.Where(pred, args...)
	return q
}

func (q @raw("*")@model.QueryName()) Limit(limit uint64) @raw("*")@model.QueryName() {
	q.BaseQuery.Limit(limit)
	return q
}

func (q @raw("*")@model.QueryName()) Offset(offset uint64) @raw("*")@model.QueryName() {
	q.BaseQuery.Offset(offset)
	return q
}

// One results only one record matching the query.
func (q @raw("*")@model.QueryName()) One() (m @model.Name@:, err error) {
	q.Limit(1).Offset(0)

	query, err := q.RawQuery()
	if err != nil {
		return
	}

	rs := New@model.Name@:ResultSet(query, nil)
	defer rs.Close()

	if rs.Next() {
		err = rs.ToModel(&m)
		if err != nil {
			return
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(&m)
			if err != nil {
				return @model.Name@:{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	} else {
		err = ceous.ErrNotFound
	}

	if err == nil {
		for _, rel := range q.BaseQuery.Relations {
			err = rel.Realize()
			if err != nil {
				return @model.Name@:{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	}

	return
}

// All return all records that match the query.
func (q @raw("*")@model.QueryName()) All() ([]@raw("*")@model.Name@:, error) {
	query, err := q.RawQuery()
	if err != nil {
		return nil, err
	}

	rs := New@model.Name@:ResultSet(query, nil)
	defer rs.Close()

	ms := make([]@raw("*")@model.Name@:, 0)
	for rs.Next() {
		m := &@model.Name@:{}
		err = rs.ToModel(m)
		if err != nil {
			return nil, err
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(m)
			if err != nil {
				return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
		ms = append(ms, m)
	}

	for _, rel := range q.BaseQuery.Relations {
		err = rel.Realize()
		if err != nil {
			return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
		}
	}

	return ms, nil
}

func (q @raw("*")@model.QueryName()) OrderBy(fields ...interface{}) @raw("*")@model.QueryName() {
	q.BaseQuery.OrderBy(fields...)
	return q
}


@for _, relation := range model.Relations {
	RenderRelation(_buffer, relation)
}
