@{
	import "github.com/jamillosantos/go-ceous/generator/models"
	import . "github.com/jamillosantos/go-ceous/generator/helpers"
	
	var ctx *models.GenContext
	var model *models.Model
}

// @model.QueryName() is the query for the model `@model.Name`.
type @model.QueryName()@: struct {
	*ceous.BaseQuery
@for _, field := range model.Fields {@
	@field.Name	ceous.SchemaField
}
}

// New@model.Name@:Query creates a new query for model `@model.Name`.
func New@model.Name@:Query(options ...ceous.CeousOption) @Pointer@model.QueryName()@: {
	bq := ceous.NewBaseQuery(options...)
	if bq.Schema == nil {
		bq.Schema = @ctx.InputPkgCtx.Ref(ctx.OutputPkg, "Schema")@:.@model.Name@:.BaseSchema
	}
	return @raw("&")@model.QueryName()@:{
		BaseQuery: bq,
	}
}

@for _, field := range model.Conditions {@
// By@field.NameForMethod@: add a filter by `@field.Field@:`.
func (q @Pointer@model.QueryName()) By@field.NameForMethod@:(value @ctx.Imports.Ref(field.Type.RefType)@:) @Pointer@model.QueryName()@: {
	@for _, condition := range field.Conditions {@
	q.BaseQuery.Where(ceous.Eq(@ctx.InputPkgCtx.Ref(ctx.OutputPkg, "Schema")@:.@condition.SchemaField@:, value@condition.StringField()@:))
	}
	return q
}
}

// Select defines what fields should be selected from the database.
func (q @Pointer@model.QueryName()) Select(fields ...ceous.SchemaField) @Pointer@model.QueryName() {
	q.BaseQuery.Select(fields...)
	return q
}

// ExcludeFields defines what fields should not be selected from the database.
func (q @Pointer@model.QueryName()) ExcludeFields(fields ...ceous.SchemaField) @Pointer@model.QueryName() {
	q.BaseQuery.ExcludeFields(fields...)
	return q
}

// Where defines the conditions for 
func (q @Pointer@model.QueryName()) Where(pred interface{}, args ...interface{}) @Pointer@model.QueryName() {
	q.BaseQuery.Where(pred, args...)
	return q
}

func (q @Pointer@model.QueryName()) Limit(limit uint64) @Pointer@model.QueryName() {
	q.BaseQuery.Limit(limit)
	return q
}

func (q @Pointer@model.QueryName()) Offset(offset uint64) @Pointer@model.QueryName() {
	q.BaseQuery.Offset(offset)
	return q
}

// One results only one record matching the query.
func (q @Pointer@model.QueryName()) One() (m @ctx.InputPkgCtx.Ref(ctx.OutputPkg, model.Name)@:, err error) {
	q.Limit(1).Offset(0)

	query, err := q.RawQuery()
	if err != nil {
		return
	}

	rs := New@model.Name@:ResultSet(query, nil)
	defer rs.Close()

	if rs.Next() {
		err = rs.ToModel(&m)
		if err != nil {
			return
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(&m)
			if err != nil {
				return @ctx.InputPkgCtx.Ref(ctx.OutputPkg, model.Name)@:{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	} else {
		err = ceous.ErrNotFound
	}

	if err == nil {
		for _, rel := range q.BaseQuery.Relations {
			err = rel.Realize()
			if err != nil {
				return @ctx.InputPkgCtx.Ref(ctx.OutputPkg, model.Name)@:{}, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
	}

	return
}

// All return all records that match the query.
func (q @Pointer@model.QueryName()) All() ([]@Pointer@ctx.InputPkgCtx.Ref(ctx.OutputPkg, model.Name)@:, error) {
	query, err := q.RawQuery()
	if err != nil {
		return nil, err
	}

	rs := New@model.Name@:ResultSet(query, nil)
	defer rs.Close()

	ms := make([]@Pointer@ctx.InputPkgCtx.Ref(ctx.OutputPkg, model.Name)@:, 0)
	for rs.Next() {
		m := &@ctx.InputPkgCtx.Ref(ctx.OutputPkg, model.Name)@:{}
		err = rs.ToModel(m)
		if err != nil {
			return nil, err
		}

		for _, rel := range q.BaseQuery.Relations {
			err = rel.Aggregate(m)
			if err != nil {
				return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
			}
		}
		ms = append(ms, m)
	}

	for _, rel := range q.BaseQuery.Relations {
		err = rel.Realize()
		if err != nil {
			return nil, err // TODO(jota): Shall this error be wrapped? At first, yes.
		}
	}

	return ms, nil
}

func (q @Pointer@model.QueryName()) OrderBy(fields ...interface{}) @Pointer@model.QueryName() {
	q.BaseQuery.OrderBy(fields...)
	return q
}


@for _, relation := range model.Relations {
	RenderRelation(_buffer, ctx, relation)
}
